-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Mitsumori.InputObject exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode
import Mitsumori.Enum.OrderByDirection
import Mitsumori.Interface
import Mitsumori.Object
import Mitsumori.Scalar
import Mitsumori.ScalarCodecs
import Mitsumori.Union


buildBigIntFilter :
    (BigIntFilterOptionalFields -> BigIntFilterOptionalFields)
    -> BigIntFilter
buildBigIntFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, gt = Absent, gte = Absent, in_ = Absent, lt = Absent, lte = Absent, neq = Absent }
    in
    { eq = optionals____.eq, gt = optionals____.gt, gte = optionals____.gte, in_ = optionals____.in_, lt = optionals____.lt, lte = optionals____.lte, neq = optionals____.neq }


type alias BigIntFilterOptionalFields =
    { eq : OptionalArgument Mitsumori.ScalarCodecs.BigInt
    , gt : OptionalArgument Mitsumori.ScalarCodecs.BigInt
    , gte : OptionalArgument Mitsumori.ScalarCodecs.BigInt
    , in_ : OptionalArgument (List Mitsumori.ScalarCodecs.BigInt)
    , lt : OptionalArgument Mitsumori.ScalarCodecs.BigInt
    , lte : OptionalArgument Mitsumori.ScalarCodecs.BigInt
    , neq : OptionalArgument Mitsumori.ScalarCodecs.BigInt
    }


{-| Type for the BigIntFilter input object.
-}
type alias BigIntFilter =
    { eq : OptionalArgument Mitsumori.ScalarCodecs.BigInt
    , gt : OptionalArgument Mitsumori.ScalarCodecs.BigInt
    , gte : OptionalArgument Mitsumori.ScalarCodecs.BigInt
    , in_ : OptionalArgument (List Mitsumori.ScalarCodecs.BigInt)
    , lt : OptionalArgument Mitsumori.ScalarCodecs.BigInt
    , lte : OptionalArgument Mitsumori.ScalarCodecs.BigInt
    , neq : OptionalArgument Mitsumori.ScalarCodecs.BigInt
    }


{-| Encode a BigIntFilter into a value that can be used as an argument.
-}
encodeBigIntFilter : BigIntFilter -> Value
encodeBigIntFilter input____ =
    Encode.maybeObject
        [ ( "eq", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecBigInt) |> Encode.optional input____.eq ), ( "gt", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecBigInt) |> Encode.optional input____.gt ), ( "gte", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecBigInt) |> Encode.optional input____.gte ), ( "in", ((Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecBigInt) |> Encode.list) |> Encode.optional input____.in_ ), ( "lt", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecBigInt) |> Encode.optional input____.lt ), ( "lte", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecBigInt) |> Encode.optional input____.lte ), ( "neq", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecBigInt) |> Encode.optional input____.neq ) ]


buildBooleanFilter :
    (BooleanFilterOptionalFields -> BooleanFilterOptionalFields)
    -> BooleanFilter
buildBooleanFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, gt = Absent, gte = Absent, in_ = Absent, lt = Absent, lte = Absent, neq = Absent }
    in
    { eq = optionals____.eq, gt = optionals____.gt, gte = optionals____.gte, in_ = optionals____.in_, lt = optionals____.lt, lte = optionals____.lte, neq = optionals____.neq }


type alias BooleanFilterOptionalFields =
    { eq : OptionalArgument Bool
    , gt : OptionalArgument Bool
    , gte : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , lt : OptionalArgument Bool
    , lte : OptionalArgument Bool
    , neq : OptionalArgument Bool
    }


{-| Type for the BooleanFilter input object.
-}
type alias BooleanFilter =
    { eq : OptionalArgument Bool
    , gt : OptionalArgument Bool
    , gte : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , lt : OptionalArgument Bool
    , lte : OptionalArgument Bool
    , neq : OptionalArgument Bool
    }


{-| Encode a BooleanFilter into a value that can be used as an argument.
-}
encodeBooleanFilter : BooleanFilter -> Value
encodeBooleanFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.bool |> Encode.optional input____.eq ), ( "gt", Encode.bool |> Encode.optional input____.gt ), ( "gte", Encode.bool |> Encode.optional input____.gte ), ( "in", (Encode.bool |> Encode.list) |> Encode.optional input____.in_ ), ( "lt", Encode.bool |> Encode.optional input____.lt ), ( "lte", Encode.bool |> Encode.optional input____.lte ), ( "neq", Encode.bool |> Encode.optional input____.neq ) ]


buildDateFilter :
    (DateFilterOptionalFields -> DateFilterOptionalFields)
    -> DateFilter
buildDateFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, gt = Absent, gte = Absent, in_ = Absent, lt = Absent, lte = Absent, neq = Absent }
    in
    { eq = optionals____.eq, gt = optionals____.gt, gte = optionals____.gte, in_ = optionals____.in_, lt = optionals____.lt, lte = optionals____.lte, neq = optionals____.neq }


type alias DateFilterOptionalFields =
    { eq : OptionalArgument Mitsumori.ScalarCodecs.Date
    , gt : OptionalArgument Mitsumori.ScalarCodecs.Date
    , gte : OptionalArgument Mitsumori.ScalarCodecs.Date
    , in_ : OptionalArgument (List Mitsumori.ScalarCodecs.Date)
    , lt : OptionalArgument Mitsumori.ScalarCodecs.Date
    , lte : OptionalArgument Mitsumori.ScalarCodecs.Date
    , neq : OptionalArgument Mitsumori.ScalarCodecs.Date
    }


{-| Type for the DateFilter input object.
-}
type alias DateFilter =
    { eq : OptionalArgument Mitsumori.ScalarCodecs.Date
    , gt : OptionalArgument Mitsumori.ScalarCodecs.Date
    , gte : OptionalArgument Mitsumori.ScalarCodecs.Date
    , in_ : OptionalArgument (List Mitsumori.ScalarCodecs.Date)
    , lt : OptionalArgument Mitsumori.ScalarCodecs.Date
    , lte : OptionalArgument Mitsumori.ScalarCodecs.Date
    , neq : OptionalArgument Mitsumori.ScalarCodecs.Date
    }


{-| Encode a DateFilter into a value that can be used as an argument.
-}
encodeDateFilter : DateFilter -> Value
encodeDateFilter input____ =
    Encode.maybeObject
        [ ( "eq", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.eq ), ( "gt", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.gt ), ( "gte", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.gte ), ( "in", ((Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input____.in_ ), ( "lt", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.lt ), ( "lte", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.lte ), ( "neq", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.neq ) ]


buildDatetimeFilter :
    (DatetimeFilterOptionalFields -> DatetimeFilterOptionalFields)
    -> DatetimeFilter
buildDatetimeFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, gt = Absent, gte = Absent, in_ = Absent, lt = Absent, lte = Absent, neq = Absent }
    in
    { eq = optionals____.eq, gt = optionals____.gt, gte = optionals____.gte, in_ = optionals____.in_, lt = optionals____.lt, lte = optionals____.lte, neq = optionals____.neq }


type alias DatetimeFilterOptionalFields =
    { eq : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , gt : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , gte : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , in_ : OptionalArgument (List Mitsumori.ScalarCodecs.Datetime)
    , lt : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , lte : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , neq : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    }


{-| Type for the DatetimeFilter input object.
-}
type alias DatetimeFilter =
    { eq : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , gt : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , gte : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , in_ : OptionalArgument (List Mitsumori.ScalarCodecs.Datetime)
    , lt : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , lte : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , neq : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    }


{-| Encode a DatetimeFilter into a value that can be used as an argument.
-}
encodeDatetimeFilter : DatetimeFilter -> Value
encodeDatetimeFilter input____ =
    Encode.maybeObject
        [ ( "eq", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDatetime) |> Encode.optional input____.eq ), ( "gt", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDatetime) |> Encode.optional input____.gt ), ( "gte", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDatetime) |> Encode.optional input____.gte ), ( "in", ((Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDatetime) |> Encode.list) |> Encode.optional input____.in_ ), ( "lt", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDatetime) |> Encode.optional input____.lt ), ( "lte", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDatetime) |> Encode.optional input____.lte ), ( "neq", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDatetime) |> Encode.optional input____.neq ) ]


buildFloatFilter :
    (FloatFilterOptionalFields -> FloatFilterOptionalFields)
    -> FloatFilter
buildFloatFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, gt = Absent, gte = Absent, in_ = Absent, lt = Absent, lte = Absent, neq = Absent }
    in
    { eq = optionals____.eq, gt = optionals____.gt, gte = optionals____.gte, in_ = optionals____.in_, lt = optionals____.lt, lte = optionals____.lte, neq = optionals____.neq }


type alias FloatFilterOptionalFields =
    { eq : OptionalArgument Float
    , gt : OptionalArgument Float
    , gte : OptionalArgument Float
    , in_ : OptionalArgument (List Float)
    , lt : OptionalArgument Float
    , lte : OptionalArgument Float
    , neq : OptionalArgument Float
    }


{-| Type for the FloatFilter input object.
-}
type alias FloatFilter =
    { eq : OptionalArgument Float
    , gt : OptionalArgument Float
    , gte : OptionalArgument Float
    , in_ : OptionalArgument (List Float)
    , lt : OptionalArgument Float
    , lte : OptionalArgument Float
    , neq : OptionalArgument Float
    }


{-| Encode a FloatFilter into a value that can be used as an argument.
-}
encodeFloatFilter : FloatFilter -> Value
encodeFloatFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.float |> Encode.optional input____.eq ), ( "gt", Encode.float |> Encode.optional input____.gt ), ( "gte", Encode.float |> Encode.optional input____.gte ), ( "in", (Encode.float |> Encode.list) |> Encode.optional input____.in_ ), ( "lt", Encode.float |> Encode.optional input____.lt ), ( "lte", Encode.float |> Encode.optional input____.lte ), ( "neq", Encode.float |> Encode.optional input____.neq ) ]


buildIntFilter :
    (IntFilterOptionalFields -> IntFilterOptionalFields)
    -> IntFilter
buildIntFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, gt = Absent, gte = Absent, in_ = Absent, lt = Absent, lte = Absent, neq = Absent }
    in
    { eq = optionals____.eq, gt = optionals____.gt, gte = optionals____.gte, in_ = optionals____.in_, lt = optionals____.lt, lte = optionals____.lte, neq = optionals____.neq }


type alias IntFilterOptionalFields =
    { eq : OptionalArgument Int
    , gt : OptionalArgument Int
    , gte : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , lt : OptionalArgument Int
    , lte : OptionalArgument Int
    , neq : OptionalArgument Int
    }


{-| Type for the IntFilter input object.
-}
type alias IntFilter =
    { eq : OptionalArgument Int
    , gt : OptionalArgument Int
    , gte : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , lt : OptionalArgument Int
    , lte : OptionalArgument Int
    , neq : OptionalArgument Int
    }


{-| Encode a IntFilter into a value that can be used as an argument.
-}
encodeIntFilter : IntFilter -> Value
encodeIntFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.int |> Encode.optional input____.eq ), ( "gt", Encode.int |> Encode.optional input____.gt ), ( "gte", Encode.int |> Encode.optional input____.gte ), ( "in", (Encode.int |> Encode.list) |> Encode.optional input____.in_ ), ( "lt", Encode.int |> Encode.optional input____.lt ), ( "lte", Encode.int |> Encode.optional input____.lte ), ( "neq", Encode.int |> Encode.optional input____.neq ) ]


buildJSONFilter :
    (JSONFilterOptionalFields -> JSONFilterOptionalFields)
    -> JSONFilter
buildJSONFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, neq = Absent }
    in
    { eq = optionals____.eq, neq = optionals____.neq }


type alias JSONFilterOptionalFields =
    { eq : OptionalArgument Mitsumori.ScalarCodecs.Json
    , neq : OptionalArgument Mitsumori.ScalarCodecs.Json
    }


{-| Type for the JSONFilter input object.
-}
type alias JSONFilter =
    { eq : OptionalArgument Mitsumori.ScalarCodecs.Json
    , neq : OptionalArgument Mitsumori.ScalarCodecs.Json
    }


{-| Encode a JSONFilter into a value that can be used as an argument.
-}
encodeJSONFilter : JSONFilter -> Value
encodeJSONFilter input____ =
    Encode.maybeObject
        [ ( "eq", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecJson) |> Encode.optional input____.eq ), ( "neq", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecJson) |> Encode.optional input____.neq ) ]


buildQuote_tagsFilter :
    (Quote_tagsFilterOptionalFields -> Quote_tagsFilterOptionalFields)
    -> Quote_tagsFilter
buildQuote_tagsFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { text = Absent, quote_id = Absent, id = Absent }
    in
    { text = optionals____.text, quote_id = optionals____.quote_id, id = optionals____.id }


type alias Quote_tagsFilterOptionalFields =
    { text : OptionalArgument StringFilter
    , quote_id : OptionalArgument UUIDFilter
    , id : OptionalArgument UUIDFilter
    }


{-| Type for the Quote\_tagsFilter input object.
-}
type alias Quote_tagsFilter =
    { text : OptionalArgument StringFilter
    , quote_id : OptionalArgument UUIDFilter
    , id : OptionalArgument UUIDFilter
    }


{-| Encode a Quote\_tagsFilter into a value that can be used as an argument.
-}
encodeQuote_tagsFilter : Quote_tagsFilter -> Value
encodeQuote_tagsFilter input____ =
    Encode.maybeObject
        [ ( "text", encodeStringFilter |> Encode.optional input____.text ), ( "quote_id", encodeUUIDFilter |> Encode.optional input____.quote_id ), ( "id", encodeUUIDFilter |> Encode.optional input____.id ) ]


buildQuote_tagsInsertInput :
    (Quote_tagsInsertInputOptionalFields -> Quote_tagsInsertInputOptionalFields)
    -> Quote_tagsInsertInput
buildQuote_tagsInsertInput fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { text = Absent, quote_id = Absent, id = Absent }
    in
    { text = optionals____.text, quote_id = optionals____.quote_id, id = optionals____.id }


type alias Quote_tagsInsertInputOptionalFields =
    { text : OptionalArgument String
    , quote_id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    }


{-| Type for the Quote\_tagsInsertInput input object.
-}
type alias Quote_tagsInsertInput =
    { text : OptionalArgument String
    , quote_id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    }


{-| Encode a Quote\_tagsInsertInput into a value that can be used as an argument.
-}
encodeQuote_tagsInsertInput : Quote_tagsInsertInput -> Value
encodeQuote_tagsInsertInput input____ =
    Encode.maybeObject
        [ ( "text", Encode.string |> Encode.optional input____.text ), ( "quote_id", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.quote_id ), ( "id", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ) ]


buildQuote_tagsOrderBy :
    (Quote_tagsOrderByOptionalFields -> Quote_tagsOrderByOptionalFields)
    -> Quote_tagsOrderBy
buildQuote_tagsOrderBy fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { text = Absent, quote_id = Absent, id = Absent }
    in
    { text = optionals____.text, quote_id = optionals____.quote_id, id = optionals____.id }


type alias Quote_tagsOrderByOptionalFields =
    { text : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , quote_id : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , id : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    }


{-| Type for the Quote\_tagsOrderBy input object.
-}
type alias Quote_tagsOrderBy =
    { text : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , quote_id : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , id : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    }


{-| Encode a Quote\_tagsOrderBy into a value that can be used as an argument.
-}
encodeQuote_tagsOrderBy : Quote_tagsOrderBy -> Value
encodeQuote_tagsOrderBy input____ =
    Encode.maybeObject
        [ ( "text", Encode.enum Mitsumori.Enum.OrderByDirection.toString |> Encode.optional input____.text ), ( "quote_id", Encode.enum Mitsumori.Enum.OrderByDirection.toString |> Encode.optional input____.quote_id ), ( "id", Encode.enum Mitsumori.Enum.OrderByDirection.toString |> Encode.optional input____.id ) ]


buildQuote_tagsUpdateInput :
    (Quote_tagsUpdateInputOptionalFields -> Quote_tagsUpdateInputOptionalFields)
    -> Quote_tagsUpdateInput
buildQuote_tagsUpdateInput fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { text = Absent, quote_id = Absent, id = Absent }
    in
    { text = optionals____.text, quote_id = optionals____.quote_id, id = optionals____.id }


type alias Quote_tagsUpdateInputOptionalFields =
    { text : OptionalArgument String
    , quote_id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    }


{-| Type for the Quote\_tagsUpdateInput input object.
-}
type alias Quote_tagsUpdateInput =
    { text : OptionalArgument String
    , quote_id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    }


{-| Encode a Quote\_tagsUpdateInput into a value that can be used as an argument.
-}
encodeQuote_tagsUpdateInput : Quote_tagsUpdateInput -> Value
encodeQuote_tagsUpdateInput input____ =
    Encode.maybeObject
        [ ( "text", Encode.string |> Encode.optional input____.text ), ( "quote_id", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.quote_id ), ( "id", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ) ]


buildQuotesFilter :
    (QuotesFilterOptionalFields -> QuotesFilterOptionalFields)
    -> QuotesFilter
buildQuotesFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, quote_text = Absent, quote_author = Absent, user_id = Absent, created_at = Absent, quote_reference = Absent }
    in
    { id = optionals____.id, quote_text = optionals____.quote_text, quote_author = optionals____.quote_author, user_id = optionals____.user_id, created_at = optionals____.created_at, quote_reference = optionals____.quote_reference }


type alias QuotesFilterOptionalFields =
    { id : OptionalArgument UUIDFilter
    , quote_text : OptionalArgument StringFilter
    , quote_author : OptionalArgument StringFilter
    , user_id : OptionalArgument UUIDFilter
    , created_at : OptionalArgument DatetimeFilter
    , quote_reference : OptionalArgument StringFilter
    }


{-| Type for the QuotesFilter input object.
-}
type alias QuotesFilter =
    { id : OptionalArgument UUIDFilter
    , quote_text : OptionalArgument StringFilter
    , quote_author : OptionalArgument StringFilter
    , user_id : OptionalArgument UUIDFilter
    , created_at : OptionalArgument DatetimeFilter
    , quote_reference : OptionalArgument StringFilter
    }


{-| Encode a QuotesFilter into a value that can be used as an argument.
-}
encodeQuotesFilter : QuotesFilter -> Value
encodeQuotesFilter input____ =
    Encode.maybeObject
        [ ( "id", encodeUUIDFilter |> Encode.optional input____.id ), ( "quote_text", encodeStringFilter |> Encode.optional input____.quote_text ), ( "quote_author", encodeStringFilter |> Encode.optional input____.quote_author ), ( "user_id", encodeUUIDFilter |> Encode.optional input____.user_id ), ( "created_at", encodeDatetimeFilter |> Encode.optional input____.created_at ), ( "quote_reference", encodeStringFilter |> Encode.optional input____.quote_reference ) ]


buildQuotesInsertInput :
    (QuotesInsertInputOptionalFields -> QuotesInsertInputOptionalFields)
    -> QuotesInsertInput
buildQuotesInsertInput fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, quote_text = Absent, quote_author = Absent, user_id = Absent, created_at = Absent, quote_reference = Absent }
    in
    { id = optionals____.id, quote_text = optionals____.quote_text, quote_author = optionals____.quote_author, user_id = optionals____.user_id, created_at = optionals____.created_at, quote_reference = optionals____.quote_reference }


type alias QuotesInsertInputOptionalFields =
    { id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , quote_text : OptionalArgument String
    , quote_author : OptionalArgument String
    , user_id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , created_at : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , quote_reference : OptionalArgument String
    }


{-| Type for the QuotesInsertInput input object.
-}
type alias QuotesInsertInput =
    { id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , quote_text : OptionalArgument String
    , quote_author : OptionalArgument String
    , user_id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , created_at : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , quote_reference : OptionalArgument String
    }


{-| Encode a QuotesInsertInput into a value that can be used as an argument.
-}
encodeQuotesInsertInput : QuotesInsertInput -> Value
encodeQuotesInsertInput input____ =
    Encode.maybeObject
        [ ( "id", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "quote_text", Encode.string |> Encode.optional input____.quote_text ), ( "quote_author", Encode.string |> Encode.optional input____.quote_author ), ( "user_id", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.user_id ), ( "created_at", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDatetime) |> Encode.optional input____.created_at ), ( "quote_reference", Encode.string |> Encode.optional input____.quote_reference ) ]


buildQuotesOrderBy :
    (QuotesOrderByOptionalFields -> QuotesOrderByOptionalFields)
    -> QuotesOrderBy
buildQuotesOrderBy fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, quote_text = Absent, quote_author = Absent, user_id = Absent, created_at = Absent, quote_reference = Absent }
    in
    { id = optionals____.id, quote_text = optionals____.quote_text, quote_author = optionals____.quote_author, user_id = optionals____.user_id, created_at = optionals____.created_at, quote_reference = optionals____.quote_reference }


type alias QuotesOrderByOptionalFields =
    { id : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , quote_text : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , quote_author : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , user_id : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , created_at : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , quote_reference : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    }


{-| Type for the QuotesOrderBy input object.
-}
type alias QuotesOrderBy =
    { id : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , quote_text : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , quote_author : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , user_id : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , created_at : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    , quote_reference : OptionalArgument Mitsumori.Enum.OrderByDirection.OrderByDirection
    }


{-| Encode a QuotesOrderBy into a value that can be used as an argument.
-}
encodeQuotesOrderBy : QuotesOrderBy -> Value
encodeQuotesOrderBy input____ =
    Encode.maybeObject
        [ ( "id", Encode.enum Mitsumori.Enum.OrderByDirection.toString |> Encode.optional input____.id ), ( "quote_text", Encode.enum Mitsumori.Enum.OrderByDirection.toString |> Encode.optional input____.quote_text ), ( "quote_author", Encode.enum Mitsumori.Enum.OrderByDirection.toString |> Encode.optional input____.quote_author ), ( "user_id", Encode.enum Mitsumori.Enum.OrderByDirection.toString |> Encode.optional input____.user_id ), ( "created_at", Encode.enum Mitsumori.Enum.OrderByDirection.toString |> Encode.optional input____.created_at ), ( "quote_reference", Encode.enum Mitsumori.Enum.OrderByDirection.toString |> Encode.optional input____.quote_reference ) ]


buildQuotesUpdateInput :
    (QuotesUpdateInputOptionalFields -> QuotesUpdateInputOptionalFields)
    -> QuotesUpdateInput
buildQuotesUpdateInput fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, quote_text = Absent, quote_author = Absent, user_id = Absent, created_at = Absent, quote_reference = Absent }
    in
    { id = optionals____.id, quote_text = optionals____.quote_text, quote_author = optionals____.quote_author, user_id = optionals____.user_id, created_at = optionals____.created_at, quote_reference = optionals____.quote_reference }


type alias QuotesUpdateInputOptionalFields =
    { id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , quote_text : OptionalArgument String
    , quote_author : OptionalArgument String
    , user_id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , created_at : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , quote_reference : OptionalArgument String
    }


{-| Type for the QuotesUpdateInput input object.
-}
type alias QuotesUpdateInput =
    { id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , quote_text : OptionalArgument String
    , quote_author : OptionalArgument String
    , user_id : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , created_at : OptionalArgument Mitsumori.ScalarCodecs.Datetime
    , quote_reference : OptionalArgument String
    }


{-| Encode a QuotesUpdateInput into a value that can be used as an argument.
-}
encodeQuotesUpdateInput : QuotesUpdateInput -> Value
encodeQuotesUpdateInput input____ =
    Encode.maybeObject
        [ ( "id", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "quote_text", Encode.string |> Encode.optional input____.quote_text ), ( "quote_author", Encode.string |> Encode.optional input____.quote_author ), ( "user_id", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.user_id ), ( "created_at", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecDatetime) |> Encode.optional input____.created_at ), ( "quote_reference", Encode.string |> Encode.optional input____.quote_reference ) ]


buildStringFilter :
    (StringFilterOptionalFields -> StringFilterOptionalFields)
    -> StringFilter
buildStringFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, gt = Absent, gte = Absent, in_ = Absent, lt = Absent, lte = Absent, neq = Absent }
    in
    { eq = optionals____.eq, gt = optionals____.gt, gte = optionals____.gte, in_ = optionals____.in_, lt = optionals____.lt, lte = optionals____.lte, neq = optionals____.neq }


type alias StringFilterOptionalFields =
    { eq : OptionalArgument String
    , gt : OptionalArgument String
    , gte : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , lt : OptionalArgument String
    , lte : OptionalArgument String
    , neq : OptionalArgument String
    }


{-| Type for the StringFilter input object.
-}
type alias StringFilter =
    { eq : OptionalArgument String
    , gt : OptionalArgument String
    , gte : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , lt : OptionalArgument String
    , lte : OptionalArgument String
    , neq : OptionalArgument String
    }


{-| Encode a StringFilter into a value that can be used as an argument.
-}
encodeStringFilter : StringFilter -> Value
encodeStringFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input____.eq ), ( "gt", Encode.string |> Encode.optional input____.gt ), ( "gte", Encode.string |> Encode.optional input____.gte ), ( "in", (Encode.string |> Encode.list) |> Encode.optional input____.in_ ), ( "lt", Encode.string |> Encode.optional input____.lt ), ( "lte", Encode.string |> Encode.optional input____.lte ), ( "neq", Encode.string |> Encode.optional input____.neq ) ]


buildTimeFilter :
    (TimeFilterOptionalFields -> TimeFilterOptionalFields)
    -> TimeFilter
buildTimeFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, gt = Absent, gte = Absent, in_ = Absent, lt = Absent, lte = Absent, neq = Absent }
    in
    { eq = optionals____.eq, gt = optionals____.gt, gte = optionals____.gte, in_ = optionals____.in_, lt = optionals____.lt, lte = optionals____.lte, neq = optionals____.neq }


type alias TimeFilterOptionalFields =
    { eq : OptionalArgument Mitsumori.ScalarCodecs.Time
    , gt : OptionalArgument Mitsumori.ScalarCodecs.Time
    , gte : OptionalArgument Mitsumori.ScalarCodecs.Time
    , in_ : OptionalArgument (List Mitsumori.ScalarCodecs.Time)
    , lt : OptionalArgument Mitsumori.ScalarCodecs.Time
    , lte : OptionalArgument Mitsumori.ScalarCodecs.Time
    , neq : OptionalArgument Mitsumori.ScalarCodecs.Time
    }


{-| Type for the TimeFilter input object.
-}
type alias TimeFilter =
    { eq : OptionalArgument Mitsumori.ScalarCodecs.Time
    , gt : OptionalArgument Mitsumori.ScalarCodecs.Time
    , gte : OptionalArgument Mitsumori.ScalarCodecs.Time
    , in_ : OptionalArgument (List Mitsumori.ScalarCodecs.Time)
    , lt : OptionalArgument Mitsumori.ScalarCodecs.Time
    , lte : OptionalArgument Mitsumori.ScalarCodecs.Time
    , neq : OptionalArgument Mitsumori.ScalarCodecs.Time
    }


{-| Encode a TimeFilter into a value that can be used as an argument.
-}
encodeTimeFilter : TimeFilter -> Value
encodeTimeFilter input____ =
    Encode.maybeObject
        [ ( "eq", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.eq ), ( "gt", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.gt ), ( "gte", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.gte ), ( "in", ((Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecTime) |> Encode.list) |> Encode.optional input____.in_ ), ( "lt", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.lt ), ( "lte", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.lte ), ( "neq", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.neq ) ]


buildUUIDFilter :
    (UUIDFilterOptionalFields -> UUIDFilterOptionalFields)
    -> UUIDFilter
buildUUIDFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, neq = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, neq = optionals____.neq }


type alias UUIDFilterOptionalFields =
    { eq : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , in_ : OptionalArgument (List Mitsumori.ScalarCodecs.Uuid)
    , neq : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    }


{-| Type for the UUIDFilter input object.
-}
type alias UUIDFilter =
    { eq : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    , in_ : OptionalArgument (List Mitsumori.ScalarCodecs.Uuid)
    , neq : OptionalArgument Mitsumori.ScalarCodecs.Uuid
    }


{-| Encode a UUIDFilter into a value that can be used as an argument.
-}
encodeUUIDFilter : UUIDFilter -> Value
encodeUUIDFilter input____ =
    Encode.maybeObject
        [ ( "eq", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.eq ), ( "in", ((Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input____.in_ ), ( "neq", (Mitsumori.ScalarCodecs.codecs |> Mitsumori.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.neq ) ]
