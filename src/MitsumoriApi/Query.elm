-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module MitsumoriApi.Query exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)
import MitsumoriApi.InputObject
import MitsumoriApi.Interface
import MitsumoriApi.Object
import MitsumoriApi.Scalar
import MitsumoriApi.Union
import ScalarCodecs


type alias NodeRequiredArguments =
    { nodeId : ScalarCodecs.Id }


{-| Retrieve a record by its `ID`

  - nodeId - The record's `ID`

-}
node :
    NodeRequiredArguments
    -> SelectionSet decodesTo MitsumoriApi.Interface.Node
    -> SelectionSet (Maybe decodesTo) RootQuery
node requiredArgs____ object____ =
    Object.selectionForCompositeField "node" [ Argument.required "nodeId" requiredArgs____.nodeId (ScalarCodecs.codecs |> MitsumoriApi.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias ProfilesCollectionOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , before : OptionalArgument ScalarCodecs.Cursor
    , after : OptionalArgument ScalarCodecs.Cursor
    , filter : OptionalArgument MitsumoriApi.InputObject.ProfilesFilter
    , orderBy : OptionalArgument (List MitsumoriApi.InputObject.ProfilesOrderBy)
    }


{-| A pagable collection of type `profiles`

  - first - Query the first `n` records in the collection
  - last - Query the last `n` records in the collection
  - before - Query values in the collection before the provided cursor
  - after - Query values in the collection after the provided cursor
  - filter - Filters to apply to the results set when querying from the collection
  - orderBy - Sort order to apply to the collection

-}
profilesCollection :
    (ProfilesCollectionOptionalArguments -> ProfilesCollectionOptionalArguments)
    -> SelectionSet decodesTo MitsumoriApi.Object.ProfilesConnection
    -> SelectionSet (Maybe decodesTo) RootQuery
profilesCollection fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, last = Absent, before = Absent, after = Absent, filter = Absent, orderBy = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "before" filledInOptionals____.before (ScalarCodecs.codecs |> MitsumoriApi.Scalar.unwrapEncoder .codecCursor), Argument.optional "after" filledInOptionals____.after (ScalarCodecs.codecs |> MitsumoriApi.Scalar.unwrapEncoder .codecCursor), Argument.optional "filter" filledInOptionals____.filter MitsumoriApi.InputObject.encodeProfilesFilter, Argument.optional "orderBy" filledInOptionals____.orderBy (MitsumoriApi.InputObject.encodeProfilesOrderBy |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "profilesCollection" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QuoteTagsCollectionOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , before : OptionalArgument ScalarCodecs.Cursor
    , after : OptionalArgument ScalarCodecs.Cursor
    , filter : OptionalArgument MitsumoriApi.InputObject.Quote_tagsFilter
    , orderBy : OptionalArgument (List MitsumoriApi.InputObject.Quote_tagsOrderBy)
    }


{-| A pagable collection of type `quote_tags`

  - first - Query the first `n` records in the collection
  - last - Query the last `n` records in the collection
  - before - Query values in the collection before the provided cursor
  - after - Query values in the collection after the provided cursor
  - filter - Filters to apply to the results set when querying from the collection
  - orderBy - Sort order to apply to the collection

-}
quote_tagsCollection :
    (QuoteTagsCollectionOptionalArguments -> QuoteTagsCollectionOptionalArguments)
    -> SelectionSet decodesTo MitsumoriApi.Object.Quote_tagsConnection
    -> SelectionSet (Maybe decodesTo) RootQuery
quote_tagsCollection fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, last = Absent, before = Absent, after = Absent, filter = Absent, orderBy = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "before" filledInOptionals____.before (ScalarCodecs.codecs |> MitsumoriApi.Scalar.unwrapEncoder .codecCursor), Argument.optional "after" filledInOptionals____.after (ScalarCodecs.codecs |> MitsumoriApi.Scalar.unwrapEncoder .codecCursor), Argument.optional "filter" filledInOptionals____.filter MitsumoriApi.InputObject.encodeQuote_tagsFilter, Argument.optional "orderBy" filledInOptionals____.orderBy (MitsumoriApi.InputObject.encodeQuote_tagsOrderBy |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "quote_tagsCollection" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QuotesCollectionOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , before : OptionalArgument ScalarCodecs.Cursor
    , after : OptionalArgument ScalarCodecs.Cursor
    , filter : OptionalArgument MitsumoriApi.InputObject.QuotesFilter
    , orderBy : OptionalArgument (List MitsumoriApi.InputObject.QuotesOrderBy)
    }


{-| A pagable collection of type `quotes`

  - first - Query the first `n` records in the collection
  - last - Query the last `n` records in the collection
  - before - Query values in the collection before the provided cursor
  - after - Query values in the collection after the provided cursor
  - filter - Filters to apply to the results set when querying from the collection
  - orderBy - Sort order to apply to the collection

-}
quotesCollection :
    (QuotesCollectionOptionalArguments -> QuotesCollectionOptionalArguments)
    -> SelectionSet decodesTo MitsumoriApi.Object.QuotesConnection
    -> SelectionSet (Maybe decodesTo) RootQuery
quotesCollection fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, last = Absent, before = Absent, after = Absent, filter = Absent, orderBy = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "before" filledInOptionals____.before (ScalarCodecs.codecs |> MitsumoriApi.Scalar.unwrapEncoder .codecCursor), Argument.optional "after" filledInOptionals____.after (ScalarCodecs.codecs |> MitsumoriApi.Scalar.unwrapEncoder .codecCursor), Argument.optional "filter" filledInOptionals____.filter MitsumoriApi.InputObject.encodeQuotesFilter, Argument.optional "orderBy" filledInOptionals____.orderBy (MitsumoriApi.InputObject.encodeQuotesOrderBy |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "quotesCollection" optionalArgs____ object____ (Basics.identity >> Decode.nullable)
